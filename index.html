<html>
  <head>
    <style>
      #graphicsCanvas {
        border: 2px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="graphicsCanvas" width="800" height="600"/>
    <script>
      const canvas = document.getElementById('graphicsCanvas');
      const ctx = canvas.getContext('2d');

      const params = {
        // Arbitrary; Internet tells me that 10x20 is 'standard' size.
        boardHeight: 20, 
        boardWidth: 10,
        maxX: 800,
        maxY: 600,
        minX: 0,
        minY: 0,
        scaleFactor: 4, // Global graphics scaling factor.
      };

      const colours = {
        black: '#000000',
        blue: '#0000ff',
        cyan: '#00ffff',
        green: '#00ff00',
        magenta: '#ff00ff',
        orange: '#ffa500',
        red: '#ff0000',
        yellow: '#ffff00',
      };

      // Abstract representation of a graphics.
      const line = (x1, y1, x2, y2, colour) => ({ render: 'line', colour, p1: [x1, y1], p2: [x2, y2] });
      const rect = (x1, y1, x2, y2, colour) => ({ render: 'rect', colour, p1: [x1, y1], p2: [x2, y2] });

      const iterZeroToN = n => f => new Array(n).fill(null).forEach((_, i) => f(i));
      const mapZeroToN = n => f => new Array(n).fill(null).map((_, i) => f(i));

      // Embed these in square matrices for easy rotation!
      const tetrominoes = [
        // I
        [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
        ],
        // O
        [
          [1, 1],
          [1, 1],
        ],
        // T
        [
          [0, 0, 0],
          [0, 1, 0],
          [1, 1, 1],
        ],
        // S
        [
          [0, 1, 1],
          [1, 1, 0],
          [0, 0, 0],
        ],
        // Z
        [
          [1, 1, 0],
          [0, 1, 1],
          [0, 0, 0],
        ],
        // J
        [
          [1, 0, 0],
          [1, 1, 1],
          [0, 0, 0],
        ],
        // L
        [
          [0, 0, 1],
          [1, 1, 1],
          [0, 0, 0],
        ],
      ];

      const [tetI, tetO, tetT, tetS, tetZ, tetJ, tetL] = [0, 1, 2, 3, 4, 5, 6, 7];

      const copyMatrix = m => m.map(row => [...row]);

      // Could be a bit more clever and use linear algebra ... which would be great if
      // we had hardware support for matrix ops.
      // Assumption: Square matrix.
      const rotateClockwise = m => {
        const n = m.length;
        const res = copyMatrix(m);

        iterZeroToN(n)(i => iterZeroToN(n)((j) => {
          res[n - j - 1][i] = m[i][j];
        }));

        return res;
      }
      const rotateAnticlockwise = m => {
        const n = m.length;
        const res = copyMatrix(m);

        iterZeroToN(n)(i => iterZeroToN(n)((j) => {
          res[i][j] = m[n - j - 1][i];
        }));

        return res;
      }

      // 'Drawing' will mean render to logical shapes.
      // Draw the board by drawing a series of vertical / horizontal lines.
      const drawBoard = () => {
        const { boardHeight, boardWidth } = params;

        const vertLines = mapZeroToN(boardWidth + 1)(i => line(i, 0, i, boardHeight));
        const horizLines = mapZeroToN(boardHeight + 1)(i => line(0, i, boardWidth, i));

        return [
          ...vertLines,
          ...horizLines,
        ];
      };

      const drawTetromino = ({ colour, matrix, x, y }) => {
        const res = [];

        matrix.forEach((row, r) => {
          row.forEach((v, c) => {
            if (v === 1) {
              const [xOff, yOff] = [x + c, y + r];

              res.push(rect(xOff, yOff, xOff + 1, yOff + 1, colour));
            }
          });
        });

        return res;
      };

      const drawField = field => {
        const { boardHeight, boardWidth } = params;
        const { black, red } = colours;
        const res = [];

        iterZeroToN(boardHeight)((i) => {
          if (fullLine(field[i])) {
            // Highlight full row. (We're relying on the assumption that the grid will be
            // drawn *above* the rects.)
            res.push(rect(0, i, boardWidth, i + 1, red));

            return;
          }

          iterZeroToN(boardWidth)((j) => {
            const colour = field[i][j];

            if (colour !== null) {
              res.push(rect(j, i, j + 1, i + 1, colour));
            }
          })
        });

        return res;
      };

      // 'Rendering' will take drawn shaps and apply transformations and generate
      // pixels.
      const applyTransforms = ts => p => 
        ts.reduce(
          ([x, y], t) => {
            switch(t.transform) {
              case 'translate':
                return [x + t.x, y + t.y];
              case 'scale':
                return [x * t.x, y * t.y];
            }
          },
          p,
        );

      const renderObj = ts => obj => {
        const transform = applyTransforms(ts);

        switch(obj.render) {
          case 'line':
            ctx.strokeStyle = obj.colour || colours.black;
            ctx.beginPath();
            ctx.moveTo(...transform(obj.p1));
            ctx.lineTo(...transform(obj.p2))
            return ctx.stroke(); // I can always tell when she gets sassified! https://youtu.be/P7gMkiOPSe
          case 'rect':
            ctx.fillStyle = obj.colour || colours.black;
            const [x1, y1] = transform(obj.p1);
            const [x2, y2] = transform(obj.p2);
            return ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }
      };

      let field = mapZeroToN(params.boardHeight)(_ => mapZeroToN(params.boardWidth)(_ => null));

      let tets = [
        {
          colour: colours.orange,
          matrix: tetrominoes[tetI],
          x: 0,
          y: 0,
        },
        {
          colour: colours.red,
          matrix: tetrominoes[tetT],
          x: 5,
          y: 0,
        },
        {
          colour: colours.green,
          matrix: tetrominoes[tetO],
          x: 0,
          y: 5,
        },
        {
          colour: colours.cyan,
          matrix: tetrominoes[tetS],
          x: 5,
          y: 5,
        },
        {
          colour: colours.magenta,
          matrix: tetrominoes[tetZ],
          x: 0,
          y: 10,
        },
        {
          colour: colours.blue,
          matrix: tetrominoes[tetJ],
          x: 5,
          y: 10,
        },
        {
          colour: colours.yellow,
          matrix: tetrominoes[tetL],
          x: 0,
          y: 15,
        },
      ];

      // Is a hypothetical position for a tet invalid?
      const checkTetCollision = (field, { matrix, x, y }) => {
        const { boardHeight, boardWidth } = params;
        const n = matrix.length;

        // Ugly `for` loops to exit early more straightforwardly.
        for (let i = 0; i < n; ++ i) {
          for (let j = 0; j < n; ++ j) {
            if (matrix[i][j] === 1) {
              const [iy, jx] = [i + y, j + x];

              if (iy < 0 || iy >= boardHeight || jx < 0 || jx >= boardWidth || field[iy][jx] !== null) {
                return true;
              }
            }
          }
        }
      };

      // In-place: Convert an active tet to part of the background field.
      const commitTetToField = (field, { colour, matrix, x, y }) => {
        const n = matrix.length;

        iterZeroToN(n)(i => iterZeroToN(n)((j) => {
          if (matrix[i][j] === 1) {
            field[i + y][j + x] = colour;
          }
        }));
      };

      const fullLine = row => row.indexOf(null) === -1;

      const clearFullLines = (field) => {
        let { boardHeight, boardWidth } = params;

        let res = 0;
        let fieldUpdated = [];
        
        field.forEach((row) => {
          if (fullLine(row)) {
            ++ res;
          } else {
            fieldUpdated.push(row);
          }
        });

        iterZeroToN(res)((_) => {
          fieldUpdated.unshift(mapZeroToN(boardWidth)(_ => null));
        });

        return {
          field: fieldUpdated,
          count: res,
        };
      };

      const render = ({ field, tets }) => {
        const renderer = renderObj([
          {
            transform: 'scale',
            x: 25,
            y: 25,
          },
          {
            transform: 'translate',
            x: 275,
            y: 50,
          }
        ]);

        const { maxX, maxY, minX, minY } = params;
        ctx.clearRect(minX, minY, maxX, maxY);

        tets.forEach((tet) => drawTetromino(tet).forEach(renderer));
        drawField(field).forEach(renderer);
        drawBoard().forEach(renderer);
      }

      const update = ({ field, tets }) => {
        const fieldUpdated = clearFullLines(field).field;
        const tetsUpdated = [];

        tets.forEach((tet) => {
          const tetMoved = {
            ...tet,
            y: tet.y + 1,
          };

          if (checkTetCollision(field, tetMoved)) {
            commitTetToField(field, tet);
          } else {
            tetsUpdated.push(tetMoved);
          }

        });

        return {
          field: fieldUpdated,
          tets: tetsUpdated,
        };
      };

      const temp = () => {
        // TODO: Make the global state *this* rather than having multiple globals
        // (`field`, `tets`).
        const state = update({ field, tets });

        render(state);

        field = state.field;
        tets = state.tets;
      };

      // TODO: Temp hack: Set up some full / partial rows to check that full-line
      // detection / clearing logic is working.
      let setFullRow = n => field[n] = mapZeroToN(params.boardWidth)(_ => 'cyan');
      setFullRow(params.boardHeight - 1);
      setFullRow(params.boardHeight - 2);
      setFullRow(params.boardHeight - 3);
      mapZeroToN(3)((i) => {
        field[params.boardHeight - 3][i] = null;
        field[params.boardHeight - 3][i + 5] = null;
      });

      render({ field, tets });
      setInterval(temp, 1000);
    </script>
  </body>
</html>
