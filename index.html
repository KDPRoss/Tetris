<html>
  <head>
    <style>
      #graphicsCanvas {
        border: 2px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="graphicsCanvas" width="800" height="600"/>
    <script>
      const canvas = document.getElementById('graphicsCanvas');
      const ctx = canvas.getContext('2d');

      const params = {
        // Arbitrary; Internet tells me that 10x20 is 'standard' size.
        boardHeight: 20, 
        boardWidth: 10,
        maxX: 800,
        maxY: 600,
        minX: 0,
        minY: 0,
        scaleFactor: 4, // Global graphics scaling factor.
        tetQueueLength: 6,
      };

      const colours = {
        black: '#000000',
        blue: '#0000ff',
        cyan: '#00ffff',
        green: '#00ff00',
        magenta: '#ff00ff',
        orange: '#ffa500',
        red: '#ff0000',
        yellow: '#ffff00',
      };

      // Abstract representation of a graphics.
      const line = (x1, y1, x2, y2, colour) => ({ render: 'line', colour, p1: [x1, y1], p2: [x2, y2] });
      const rect = (x1, y1, x2, y2, colour) => ({ render: 'rect', colour, p1: [x1, y1], p2: [x2, y2] });

      const iterZeroToN = n => f => new Array(n).fill(null).forEach((_, i) => f(i));
      const mapZeroToN = n => f => new Array(n).fill(null).map((_, i) => f(i));

      // Embed these in square matrices for easy rotation!
      const tets = [
        // I
        [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
        ],
        // O
        [
          [1, 1],
          [1, 1],
        ],
        // T
        [
          [0, 0, 0],
          [0, 1, 0],
          [1, 1, 1],
        ],
        // S
        [
          [0, 1, 1],
          [1, 1, 0],
          [0, 0, 0],
        ],
        // Z
        [
          [1, 1, 0],
          [0, 1, 1],
          [0, 0, 0],
        ],
        // J
        [
          [1, 0, 0],
          [1, 1, 1],
          [0, 0, 0],
        ],
        // L
        [
          [0, 0, 1],
          [1, 1, 1],
          [0, 0, 0],
        ],
      ];

      const [tetI, tetO, tetT, tetS, tetZ, tetJ, tetL] = [0, 1, 2, 3, 4, 5, 6, 7];

      const copyMatrix = m => m.map(row => [...row]);

      // Could be a bit more clever and use linear algebra ... which would be great if
      // we had hardware support for matrix ops.
      // Assumption: Square matrix.
      const rotateClockwise = m => {
        const n = m.length;
        const res = copyMatrix(m);

        iterZeroToN(n)(i => iterZeroToN(n)((j) => {
          res[n - j - 1][i] = m[i][j];
        }));

        return res;
      }
      const rotateAnticlockwise = m => {
        const n = m.length;
        const res = copyMatrix(m);

        iterZeroToN(n)(i => iterZeroToN(n)((j) => {
          res[i][j] = m[n - j - 1][i];
        }));

        return res;
      }

      // 'Drawing' will mean render to logical shapes.
      // Draw the board by drawing a series of vertical / horizontal lines.
      const drawBoard = () => {
        const { boardHeight, boardWidth } = params;

        const vertLines = mapZeroToN(boardWidth + 1)(i => line(i, 0, i, boardHeight));
        const horizLines = mapZeroToN(boardHeight + 1)(i => line(0, i, boardWidth, i));

        return [
          ...vertLines,
          ...horizLines,
        ];
      };

      const drawTet = ({ colour, matrix, x, y }) => {
        const res = [];

        matrix.forEach((row, r) => {
          row.forEach((v, c) => {
            if (v === 1) {
              const [xOff, yOff] = [x + c, y + r];

              res.push(rect(xOff, yOff, xOff + 1, yOff + 1, colour));
            }
          });
        });

        return res;
      };

      const drawField = field => {
        const { boardHeight, boardWidth } = params;
        const { black, red } = colours;
        const res = [];

        iterZeroToN(boardHeight)((i) => {
          if (fullLine(field[i])) {
            // Highlight full row. (We're relying on the assumption that the grid will be
            // drawn *above* the rects.)
            res.push(rect(0, i, boardWidth, i + 1, red));

            return;
          }

          iterZeroToN(boardWidth)((j) => {
            const colour = field[i][j];

            if (colour !== null) {
              res.push(rect(j, i, j + 1, i + 1, colour));
            }
          })
        });

        return res;
      };

      // 'Rendering' will take drawn shaps and apply transformations and generate
      // pixels.
      const applyTransforms = ts => p => 
        ts.reduce(
          ([x, y], t) => {
            switch(t.transform) {
              case 'translate':
                return [x + t.x, y + t.y];
              case 'scale':
                return [x * t.x, y * t.y];
            }
          },
          p,
        );

      const renderObj = ts => obj => {
        const transform = applyTransforms(ts);

        switch(obj.render) {
          case 'line':
            ctx.strokeStyle = obj.colour || colours.black;
            ctx.beginPath();
            ctx.moveTo(...transform(obj.p1));
            ctx.lineTo(...transform(obj.p2))
            return ctx.stroke(); // I can always tell when she gets sassified! https://youtu.be/P7gMkiOPSe
          case 'rect':
            ctx.fillStyle = obj.colour || colours.black;
            const [x1, y1] = transform(obj.p1);
            const [x2, y2] = transform(obj.p2);
            return ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }
      };

      const fieldInit = mapZeroToN(params.boardHeight)(_ => mapZeroToN(params.boardWidth)(_ => null));

      // TODO: Remove all of this.
      const tetsInit = [
        {
          colour: colours.orange,
          matrix: tets[tetI],
          x: 0,
          y: 0,
        },
        {
          colour: colours.red,
          matrix: tets[tetT],
          x: 5,
          y: 0,
        },
        {
          colour: colours.green,
          matrix: tets[tetO],
          x: 0,
          y: 5,
        },
        {
          colour: colours.cyan,
          matrix: tets[tetS],
          x: 5,
          y: 5,
        },
        {
          colour: colours.magenta,
          matrix: tets[tetZ],
          x: 0,
          y: 10,
        },
        {
          colour: colours.blue,
          matrix: tets[tetJ],
          x: 5,
          y: 10,
        },
        {
          colour: colours.yellow,
          matrix: tets[tetL],
          x: 0,
          y: 15,
        },
      ];

      // TODO: Consider nonuniform probability distribution?
      const randomTet = () => ({
        colour: colours.red, // TODO: Random colour.
        matrix: tets[Math.floor(Math.random() * tets.length)], // TODO: Random rotation.
        x: Math.floor(params.boardWidth / 2),
        y: 0,
      });

      const populateTetQueue = (queue) => {
        const { tetQueueLength } = params;

        const freshTets = mapZeroToN(tetQueueLength - queue.length)(randomTet);
        
        return [...queue, ...freshTets];
      };

      // Keep of the global, mutable state in one place.
      let state = {
        field: fieldInit,
        keysDown: new Set(),
        queue: populateTetQueue([]),
        tets: [randomTet()],
      };

      // Is a hypothetical position for a tet invalid?
      const checkTetCollision = (field, { matrix, x, y }) => {
        const { boardHeight, boardWidth } = params;
        const n = matrix.length;

        // Ugly `for` loops to exit early more straightforwardly.
        for (let i = 0; i < n; ++ i) {
          for (let j = 0; j < n; ++ j) {
            if (matrix[i][j] === 1) {
              const [iy, jx] = [i + y, j + x];

              if (iy < 0 || iy >= boardHeight || jx < 0 || jx >= boardWidth || field[iy][jx] !== null) {
                return true;
              }
            }
          }
        }
      };

      // In-place: Convert an active tet to part of the background field.
      const commitTetToField = (field, { colour, matrix, x, y }) => {
        const n = matrix.length;

        iterZeroToN(n)(i => iterZeroToN(n)((j) => {
          if (matrix[i][j] === 1) {
            field[i + y][j + x] = colour;
          }
        }));
      };

      const fullLine = row => row.indexOf(null) === -1;

      const clearFullLines = (field) => {
        let { boardHeight, boardWidth } = params;

        let res = 0;
        let fieldUpdated = [];
        
        field.forEach((row) => {
          if (fullLine(row)) {
            ++ res;
          } else {
            fieldUpdated.push(row);
          }
        });

        iterZeroToN(res)((_) => {
          fieldUpdated.unshift(mapZeroToN(boardWidth)(_ => null));
        });

        return {
          field: fieldUpdated,
          count: res,
        };
      };

      const drawTetQueue = (queue) => {
        const res = [];
        const padSize = 6; // Max tet size is 4; this gives us enough padding.

        queue.forEach((tet, i) => {
          const tetToRender = {
            ...tet,
            x: 1,
            y: 1 + i * padSize,
          };

          res.push(...drawTet(tetToRender));
        });

        // Draw a box to highlight which element of the queue is the next tet.
        const { matrix, colour } = queue[0];
        const n = matrix.length + 2;
        iterZeroToN(2)((i) => {
          res.push(line(i * n, 0, i * n, n, 'black'))
          res.push(line(0, i * n, n, i * n, 'black'));
        });

        return res;
      };

      const render = ({ field, queue, tets }) => {
        const renderer = renderObj([
          {
            transform: 'scale',
            x: 25,
            y: 25,
          },
          {
            transform: 'translate',
            x: 275,
            y: 50,
          }
        ]);

        const rendererQueue = renderObj([
          {
            transform: 'scale',
            x: 15,
            y: 15,
          },
          {
            transform: 'translate',
            x: 150,
            y: 50,
          }
        ]);

        const { maxX, maxY, minX, minY } = params;
        ctx.clearRect(minX, minY, maxX, maxY);

        drawTetQueue(queue).forEach(rendererQueue);
        tets.forEach((tet) => drawTet(tet).forEach(renderer));
        drawField(field).forEach(renderer);
        drawBoard().forEach(renderer);
      }

      const update = (state) => {
        const { field, keysDown, queue, tets } = state;
        const tetsUpdated = [];

        tets.forEach((tet) => {
          const tetMoved = {
            ...tet,
            y: tet.y + 1,
          };

          if (checkTetCollision(field, tetMoved)) {
            commitTetToField(field, tet);
            
            // Generate a replacement.
            tetsUpdated.push(queue.shift());
          } else {
            tetsUpdated.push(tetMoved);
          }
        });

        return {
          ...state,
          field: clearFullLines(field).field,
          queue: populateTetQueue(queue),
          tets: tetsUpdated,
        };
      };

      // Magical key codes.
      const rightArrow = 39;
      const leftArrow  = 37;
      const downArrow = 40;
      const upArrow = 38;
      const space = 32;

      const keyDownHandler = (event) => {
        const { keyCode } = event;

        if (keyCode) {
          state.keysDown.add(keyCode);
        }
      };

      const keyUpHandler = (event) => {
        const { keyCode } = event;

        if (keyCode) {
          state.keysDown.delete(keyCode)
        }
      }

        // Not sure if this is a WAT!? or AMAZE!
      const tick = () => render(state = update(state));

      // TODO: Temp hack: Set up some full / partial rows to check that full-line
      // detection / clearing logic is working.
      let setFullRow = (n) => {
        state.field[n] = mapZeroToN(params.boardWidth)(_ => 'cyan');
      };
      setFullRow(params.boardHeight - 1);
      setFullRow(params.boardHeight - 2);
      setFullRow(params.boardHeight - 3);
      mapZeroToN(3)((i) => {
        state.field[params.boardHeight - 3][i] = null;
        state.field[params.boardHeight - 3][i + 5] = null;
      });

      const handleInput = () => {
        const { field, keysDown, tets } = state;
        const tetsUpdated = [];
        let needRerender = false;

        tets.forEach((tet) => {
          const tetMoved = { ...tet };

          keysDown.forEach((keyCode) => {
            switch(keyCode) {
              case leftArrow:
                return -- tetMoved.x;
              case rightArrow:
                return ++ tetMoved.x;
              case space:
                return ++ tetMoved.y;
              case upArrow:
                tetMoved.matrix = rotateClockwise(tetMoved.matrix);
                return;
              case downArrow:
                tetMoved.matrix = rotateAnticlockwise(tetMoved.matrix);
                return;
            }
          });

          if (checkTetCollision(field, tetMoved)) {
            tetsUpdated.push(tet);
          } else {
            tetsUpdated.push(tetMoved);
            needRerender = true;
          }
        });

        state = {
          ...state,
          field,
          keysDown,
          tets: tetsUpdated,
        }

        if (needRerender) {
          render(state);
        }
      };

      document.addEventListener('keydown', keyDownHandler);
      document.addEventListener('keyup', keyUpHandler);

      render(state);
      setInterval(handleInput, 75);
      setInterval(tick, 1000);
    </script>
  </body>
</html>
