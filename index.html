<html>
  <head>
    <style>
      #graphicsCanvas {
        border: 2px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="graphicsCanvas" width="800" height="600"/>
    <script>
      const canvas = document.getElementById('graphicsCanvas');
      const ctx = canvas.getContext('2d');

      const params = {
        // Arbitrary; Internet tells me that 10x20 is 'standard' size.
        boardHeight: 20, 
        boardWidth: 10,
        maxX: 800,
        maxY: 600,
        minX: 0,
        minY: 0,
        scaleFactor: 4, // Global graphics scaling factor.
      };

      const colours = {
        black: '#000000',
        blue: '#0000ff',
        cyan: '#00ffff',
        green: '#00ff00',
        magenta: '#ff00ff',
        orange: '#ffa500',
        red: '#ff0000',
        yellow: '#ffff00',
      };

      // Abstract representation of a graphics.
      const line = (x1, y1, x2, y2, colour) => ({ render: 'line', colour, p1: [x1, y1], p2: [x2, y2] });
      const rect = (x1, y1, x2, y2, colour) => ({ render: 'rect', colour, p1: [x1, y1], p2: [x2, y2] });

      const iterZeroToN = n => f => new Array(n).fill(null).forEach((_, i) => f(i));
      const mapZeroToN = n => f => new Array(n).fill(null).map((_, i) => f(i));

      // Embed these in square matrices for easy rotation!
      const tetrominoes = [
        // I
        [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
        ],
        // O
        [
          [1, 1],
          [1, 1],
        ],
        // T
        [
          [0, 0, 0],
          [0, 1, 0],
          [1, 1, 1],
        ],
        // S
        [
          [0, 1, 1],
          [1, 1, 0],
          [0, 0, 0],
        ],
        // Z
        [
          [1, 1, 0],
          [0, 1, 1],
          [0, 0, 0],
        ],
        // J
        [
          [1, 0, 0],
          [1, 1, 1],
          [0, 0, 0],
        ],
        // L
        [
          [0, 0, 1],
          [1, 1, 1],
          [0, 0, 0],
        ],
      ];

      const [tetI, tetO, tetT, tetS, tetZ, tetJ, tetL] = [0, 1, 2, 3, 4, 5, 6, 7];

      // Could be a bit more clever and use linear algebra ... which would be great if
      // we had hardware support for matrix ops.
      // Assumption: Square matrix.
      const rotateRight = m => {
        const n = m.length;
        const res = [];

        iterZeroToN(n)((i) => {
          res.push(mapZeroToN(n)(j => m[j][i]));
        });

        return res;
      }

      // 'Drawing' will mean render to logical shapes.
      // Draw the board by drawing a series of vertical / horizontal lines.
      const drawBoard = () => {
        const { boardHeight, boardWidth } = params;

        const vertLines = mapZeroToN(boardWidth + 1)(i => line(i, 0, i, boardHeight));
        const horizLines = mapZeroToN(boardHeight + 1)(i => line(0, i, boardWidth, i));

        return [
          ...vertLines,
          ...horizLines,
        ];
      };

      const drawTetromino = ({ colour, matrix, x, y }) => {
        const res = [];

        matrix.forEach((row, r) => {
          row.forEach((v, c) => {
            if (v === 1) {
              const [xOff, yOff] = [x + r, y + c];

              res.push(rect(xOff, yOff, xOff + 1, yOff + 1, colour));
            }
          });
        });

        return res;
      };

      // 'Rendering' will take drawn shaps and apply transformations and generate
      // pixels.
      const applyTransforms = ts => p => 
        ts.reduce(
          ([x, y], t) => {
            switch(t.transform) {
              case 'translate':
                return [x + t.x, y + t.y];
              case 'scale':
                return [x * t.x, y * t.y];
            }
          },
          p,
        );

      const renderObj = ts => obj => {
        const transform = applyTransforms(ts);

        switch(obj.render) {
          case 'line':
            ctx.strokeStyle = obj.colour || colours.black;
            ctx.beginPath();
            ctx.moveTo(...transform(obj.p1));
            ctx.lineTo(...transform(obj.p2))
            return ctx.stroke(); // I can always tell when she gets sassified! https://youtu.be/P7gMkiOPSe
          case 'rect':
            ctx.fillStyle = obj.colour || colours.black;
            const [x1, y1] = transform(obj.p1);
            const [x2, y2] = transform(obj.p2);
            return ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }
      };

      const tets = [
        {
          colour: colours.orange,
          matrix: tetrominoes[tetI],
          x: 0,
          y: 0,
        },
        {
          colour: colours.red,
          matrix: tetrominoes[tetT],
          x: 5,
          y: 0,
        },
        {
          colour: colours.green,
          matrix: tetrominoes[tetO],
          x: 0,
          y: 5,
        },
        {
          colour: colours.cyan,
          matrix: tetrominoes[tetS],
          x: 5,
          y: 5,
        },
        {
          colour: colours.magenta,
          matrix: tetrominoes[tetZ],
          x: 0,
          y: 10,
        },
        {
          colour: colours.blue,
          matrix: tetrominoes[tetJ],
          x: 5,
          y: 10,
        },
        {
          colour: colours.yellow,
          matrix: tetrominoes[tetL],
          x: 0,
          y: 15,
        },
      ];

      const temp = () => {
        const { maxX, maxY, minX, minY } = params;
        ctx.clearRect(minX, minY, maxX, maxY);

        const renderer = renderObj([
          {
            transform: 'scale',
            x: 25,
            y: 25,
          },
          {
            transform: 'translate',
            x: 275,
            y: 50,
          }
        ]);

        tets.forEach((tet) => {
          drawTetromino(tet).forEach(renderer);
          tet.matrix = rotateRight(tet.matrix);
        });

        drawBoard().forEach(renderer);
      };

      setInterval(temp, 1000);
    </script>
  </body>
</html>
